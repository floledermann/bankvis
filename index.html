<!doctype html>
<html class="no-js" lang="en">
<meta charset="utf-8">
<title>Bank</title>
<meta name="description" content="">
<meta name="viewport" content="width=device-width, initial-scale=1">

<style type="text/css">
body {
    font: 10px sans-serif;
}
svg .axis {
    text-size: 8;
    shape-rendering: crispEdges;
}
svg .axis line,
svg .axis path {
  fill: none;
  stroke: #000;
}

svg g.transaction.minus .bar {
    stroke: #ff0000;
}

svg g.transaction.plus .bar {
    stroke: #00ee00;
}
svg rect.pane {
  cursor: move;
  fill: none;
  pointer-events: all;
}


.droptarget {
    border: 2px solid #9999ff;
    border-radius: 10px;
    margin: 1em 0;
    padding: 1em;
    font-size: 3em;
}

.droptarget.dropping {
    background-color: #eeeeff;
}
</style>

<body>


<main>

<div class="droptarget">
Drop banking data here (CSV) <!--, JSON, XLS, XLSX)-->
</div>

<form id="balanceForm">
<select>
<option selected value="start">Initial Balance</option>
<option>Final Balance</option>
</select>
<input id="initialBalance" type="number" value="0" step="any">
</form>

<svg id="fig1" width="100%" height="400px"></svg>

<script src="d3.js"></script>
<script src="moment-with-langs.js"></script>

<script>

var MARGIN = {top: 20, right: 10, bottom: 20, left: 40},   
    PIXELS_PER_DAY = 30,    // 80 px per day is sufficient to have a tick for each day
    BAR_WIDTH = 6,
    BAR_OFFSET_POSITIVE = 0,
    BAR_OFFSET_NEGATIVE = 10;


var data = [];

var initialBalance = 0;
    max_balance = 0,
    min_balance = 0;

var dateKey = null,
    valueKey = 'Betrag',
    balanceKey = '_balance';
    
function updateBalance(e) {
    initialBalance = Math.round(parseFloat(document.getElementById("initialBalance").value) * 100);
    updateData();
    e.stopPropagation();
    e.preventDefault();
}
document.getElementById("balanceForm").addEventListener('submit', updateBalance, false);
document.getElementById("initialBalance").addEventListener('blur', updateBalance, false);

d3.dsv(";", "text/plain")('2013-2016.csv', convertRow, function(loadedData) {
    data = loadedData;
    updateData();
});

fileDnD('.droptarget', function(files) {  

  // if (!f.type.match('application/json')) {
   // alert('Not a JSON file!');
 // }

  var reader = new FileReader();

  reader.onloadend = function(e) {
    //var result = JSON.parse(this.result);
    //console.log(result);
    var loadedData = d3.dsv(";", "text/plain").parse(this.result, convertRow);
    data = data.concat(loadedData);
    updateData();
  };
  
  reader.readAsText(files[0]);
});

function toNum(str) {
    var parsed;
    parsed = str.replace(/[-+\.,]/g,'');
    if (/^[0-9]+$/.test(parsed)) {
        parsed = str.split(/\.|,/);
        if (parsed.length > 1) {
            parsed = parsed.slice(0,parsed.length-1).join('') + '.' + parsed[parsed.length-1];
        }
        else {
            parsed = parsed[0];
        }
        return Math.round(Number(parsed) * 100);
    }
    return str;
}

function convertValue(value, key) {
    if (value === undefined) return value;
    // date?
    // rough check for performance reasons
    if (value && value.length > 9 && value.length < 25) {
        var parsed = moment(value, ['DD.MM.YYYY', 'YYYY-MM-DD'], true);
        if (parsed.isValid()) {
            dateKey = key;
            return parsed;
        }
    }
    // number?
    return toNum(value);
}

function convertRow(d) {
    var keys = Object.keys(d),
        result = {};
    //console.log(d);
    for (var i=0; i<keys.length; i++) {
        var key = keys[i],
            value = d[key];
        
        result[key] = convertValue(value, key);
    }
    return result;
}

function updateData() {

    if (!dateKey) return;
    
    data.sort(function(a,b) {
        // sort by day, within day first positive then negative balances
        // use milliseconds to speed up calculations (this will be done often!)
        time_a = a[dateKey].valueOf();
        time_b = b[dateKey].valueOf();
        
        if (time_a == time_b) {
            return b[valueKey] - a[valueKey];
        }
        return time_a - time_b;
    });
    
    var balance = initialBalance;
    
    max_balance = balance;
    min_balance = balance;
    
    data.forEach(function(d){
        balance += d[valueKey];
        d[balanceKey] = balance;
        if (balance > max_balance) max_balance = balance;
        if (balance < min_balance) min_balance = balance;
    });
    
    min_balance = Math.min(min_balance, 0);
    max_balance = Math.max(max_balance, 0);

    updatePlot();
}

function selectOrCreate(parent, tagName, className) {
    var sel = parent.select(tagName + (className ? '.' + className : ''));
    if (sel.empty()) {
        sel = parent.append(tagName);
        sel.attr('class', className);
    }
    return sel;
}

var zoom = d3.behavior.zoom()
    .on("zoom", updateZoom);

var svg = d3.select('#fig1'),
    svgEl = svg.node(),
    width = svgEl.clientWidth - MARGIN.left - MARGIN.right,
    height = svgEl.clientHeight - MARGIN.top - MARGIN.bottom;

var xAxisEl = selectOrCreate(svg,'g','axis axis-x'),
    yAxisEl = selectOrCreate(svg,'g','axis axis-y'),
    main = selectOrCreate(svg,'g','main');
    pane = selectOrCreate(svg,'rect','pane').attr("width", width).attr("height", height).call(zoom);

var x = d3.time.scale()
    .range([MARGIN.left + 10, width]);

var y = d3.scale.linear()
    .range([height, MARGIN.bottom]);
    
var xAxis = d3.svg.axis()
    .scale(x)
    .orient('bottom');

var yAxis = d3.svg.axis()
    .scale(y)
    .orient('left')
    .ticks(8);
        


function updatePlot() {
    // TODO: move setup to global init function
    var start_date = moment(data[0][dateKey]).subtract('days', 10),
        end_date = moment(data[data.length - 1][dateKey]),
        num_days = end_date.diff(start_date, 'days'),
        min_days = Math.floor((width - MARGIN.left - 10) / PIXELS_PER_DAY);
        
    var DOMAIN_X = [moment(end_date).subtract('days', min_days).toDate(), end_date.toDate()];
        DOMAIN_Y = [min_balance/100, max_balance/100];
    
    x.domain(DOMAIN_X).nice();      
    y.domain(DOMAIN_Y).nice();
    
    //x.range([-num_days * 80, 0]);
    
    zoom.scaleExtent([1 / (num_days * PIXELS_PER_DAY / width), 1]);
    zoom.x(x);

    
    xAxisEl
        .attr("transform", "translate(0," + height + ")")
        .call(xAxis);
    
    yAxisEl
        .attr("transform", "translate(" + MARGIN.left + ",0)")
        .call(yAxis)
 
    var plot = main.selectAll('g.transaction').data(data, function(d) {
        return d[dateKey].format() + " - " + d[balanceKey] + " - " + d[valueKey];
    });
    
    var initial = plot.empty();
    
    function barOffsetX(d) {
        return (d[valueKey] > 0) ? BAR_OFFSET_POSITIVE : BAR_OFFSET_NEGATIVE;
    }

    var barPositionAttrs = {
            x1: function(d, i) { return x(d[dateKey].toDate()) + barOffsetX(d) + BAR_WIDTH / 2; },
            x2: function(d, i) { return x(d[dateKey].toDate()) + barOffsetX(d) + BAR_WIDTH / 2; },
            y1: function(d) { return y((d[balanceKey] - d[valueKey]) / 100); },
            y2: function(d) { return y(d[balanceKey] / 100); }
        };
    var tickPositionAttrs = function(d,i) {
        if (i>0) {
            var d0 = data[i-1];
            if ((d[dateKey].valueOf() == d0[dateKey].valueOf()) && ((d[valueKey] > 0) == (d0[valueKey] > 0))) {
                return {
                    x1: x(d[dateKey].toDate()) + barOffsetX(d) - 2,
                    x2: x(d[dateKey].toDate()) + barOffsetX(d) + BAR_WIDTH,
                    y1: y(d0[balanceKey] / 100),
                    y2: y(d0[balanceKey] / 100)
                }
            }
        }
        return {
            display: 'none'
        }
    }
    var levelPositionAttrs = function(d,i) {
        if (i>0) {
            var d0 = data[i-1];
            if (d[dateKey].valueOf() != d0[dateKey].valueOf()) {
                return {
                    x1: x(d0[dateKey].toDate()) + BAR_OFFSET_NEGATIVE + BAR_WIDTH,
                    x2: x(d[dateKey].toDate()),
                    y1: y(d0[balanceKey] / 100),
                    y2: y(d0[balanceKey] / 100)
                };
            }
        }
        return {
            display: 'none'
        }
    }
        
    // existing elements
    plot.each(function(d,i){
        var el = d3.select(this);
        
        el.select('line.bar')
            .transition()
            .duration(750)
            .attr(barPositionAttrs);    
    
        el.select('line.tick')
            .transition()
            .duration(750)
            .attr(tickPositionAttrs(d,i));    

        el.select('line.level')
            .transition()
            .duration(750)
            .attr(levelPositionAttrs(d,i));    
    });
    
    // new elements
    // TODO: intorduce hierarchical grouping into days!
    
    var enter = plot.enter()
        .append('g')
        .attr({
            'class': function(d) { return 'transaction ' + (d[valueKey] < 0 ? 'minus' : 'plus'); },
            opacity: 0
        })
        .each(function(d,i){
            var el = d3.select(this);
            
            el.append('line')
                .attr({
                    'class': 'tick',
                    fill: 'none',
                    'stroke-width': 1,
                    stroke: '#444444',
                    'shape-rendering': 'crispEdges'
               })
                .attr(tickPositionAttrs(d,i))
            ;
            el.append('line')
                .attr({
                    'class': 'level',
                    fill: 'none',
//                        stroke: '#999999',
                    stroke: '#dddddd',
                    'stroke-width': 1,
                    'shape-rendering': 'crispEdges',
                    //'stroke-dasharray': '3 3'
                })
                .attr(levelPositionAttrs(d,i));

            el.append('line')
                .attr({
                    'class': 'bar',
                    fill: 'none',
                    'stroke-width': BAR_WIDTH,
                    //'shape-rendering': 'crispEdges'

                })
                .attr(barPositionAttrs)
            ;

        })
    ;
        
    // don't animate initial display
    if (!initial) {
        enter = enter.transition().delay(750);
    }    
    enter.attr({
        opacity: 1.0
    });
    
    // removed elements
    plot.exit().remove();
    
        
}

function updateZoom() {
    console.log(zoom.scale());
    svg.select(".axis-x").call(xAxis);
    svg.select(".axis-y").call(yAxis);
    main.attr("transform", "translate(" + zoom.translate()[0] + ",0) scale(" + zoom.scale() + ",1)");
}


function fileDnD(selector, callback) {

  var el_ = document.querySelector(selector);
  
  function stop(e) {
    e.stopPropagation();
    e.preventDefault();
  }

  function dragenter(e) {
    stop(e);
    el_.classList.add('dropping');
  };
  
  function dragleave(e) {
    stop(e);
    el_.classList.remove('dropping');
  };


  function drop(e) {
    stop(e);
    el_.classList.remove('dropping');
    callback(e.dataTransfer.files, e);
  };

  el_.addEventListener('dragenter', dragenter, false);
  el_.addEventListener('dragover', stop, false);
  el_.addEventListener('dragleave', dragleave, false);
  el_.addEventListener('drop', drop, false);
};

</script>
</body>
</html>
